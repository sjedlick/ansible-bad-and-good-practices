{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ansible - Good and Bad Practices A collection of good and bad Ansible code examples. Name your tasks Use Modules before run-commands Use native yaml syntax Use the copy-module or template-module instead of lineinfile-module Avoid unintended side effects when running playbooks Turn off gather_facts if not needed Prefix your variables Contributing If you want to contribute you can create a merge request so other colleagues will discuss the code with you. Make sure to add both a good and a bad practice to your code example. Make sure that: - your code won't contain credentials - you've commented the code why it is a good or bad practice - your code can be easily run, so please add a full playbook if possible - be open to discuss with your colleagues","title":"Ansible - Good and Bad Practices"},{"location":"#ansible-good-and-bad-practices","text":"A collection of good and bad Ansible code examples. Name your tasks Use Modules before run-commands Use native yaml syntax Use the copy-module or template-module instead of lineinfile-module Avoid unintended side effects when running playbooks Turn off gather_facts if not needed Prefix your variables","title":"Ansible - Good and Bad Practices"},{"location":"#contributing","text":"If you want to contribute you can create a merge request so other colleagues will discuss the code with you. Make sure to add both a good and a bad practice to your code example. Make sure that: - your code won't contain credentials - you've commented the code why it is a good or bad practice - your code can be easily run, so please add a full playbook if possible - be open to discuss with your colleagues","title":"Contributing"},{"location":"avoid_sideeffects/","text":"Avoid unintended side effects when running playbooks When writing tasks that can target different environments, make sure that the playbook-run only targets the environments that you really want to change. Bad Suppose you have a list of environments defined in the group_vars : environments: - dev - qa - prod In the playbook you can delete databases based on the environment: --- - hosts: - localhost vars: db_list_backend: - cms - fms tasks: - name: Drop all backend databases community.mysql.mysql_db: login_user: mysqlroot login_password: \"password\" login_host: \"mysqlserver\" name: \"{{ item.0 }}\" state: absent loop: \"{{ db_list_backend | product(environments) }}\" Then you would need to call the playbook like this to only delete databases on the dev-environment: ansible-playbook playbook.yaml --extra-vars='{environments: [dev]}' But what would happen if you ran the playbook with the extra-vars ? All environments would be deleted - probably not what you'd expect. Good Instead of relying on the environments variable being correctly set, you can do two things: Use a vars_prompt to ask for the environment to be deleted. Since you cannot define allowed variables in a vars-prompt , you can use an assert -task to check for allowed values. This way, you cannot accidentally delete the production databases. --- - hosts: - localhost vars: db_list_backend: - cms - fms allowed_environments: - dev - qa vars_prompt: - name: db_environment prompt: \"Attention: This will delete all databases in the desired environment! Please enter the environment (dev, qa):\" tasks: - name: Assert that db_environment is allowed environment ansible.builtin.assert: that: db_environment in allowed_environments fail_msg: \"{{ db_environment }} is not a valid environment\" tags: - always - name: Drop all backend databases community.mysql.mysql_db: login_user: mysqlroot login_password: \"password\" login_host: \"mysqlserver\" name: \"{{ item }}\" state: absent loop: \"{{ db_list_backend }}\" The final ansible-playbook call would look like this: ansible-playbook playbook.yaml --extra-vars=\"db_environment=dev\"","title":"Avoid unintended side effects when running playbooks"},{"location":"avoid_sideeffects/#avoid-unintended-side-effects-when-running-playbooks","text":"When writing tasks that can target different environments, make sure that the playbook-run only targets the environments that you really want to change.","title":"Avoid unintended side effects when running playbooks"},{"location":"avoid_sideeffects/#bad","text":"Suppose you have a list of environments defined in the group_vars : environments: - dev - qa - prod In the playbook you can delete databases based on the environment: --- - hosts: - localhost vars: db_list_backend: - cms - fms tasks: - name: Drop all backend databases community.mysql.mysql_db: login_user: mysqlroot login_password: \"password\" login_host: \"mysqlserver\" name: \"{{ item.0 }}\" state: absent loop: \"{{ db_list_backend | product(environments) }}\" Then you would need to call the playbook like this to only delete databases on the dev-environment: ansible-playbook playbook.yaml --extra-vars='{environments: [dev]}' But what would happen if you ran the playbook with the extra-vars ? All environments would be deleted - probably not what you'd expect.","title":"Bad"},{"location":"avoid_sideeffects/#good","text":"Instead of relying on the environments variable being correctly set, you can do two things: Use a vars_prompt to ask for the environment to be deleted. Since you cannot define allowed variables in a vars-prompt , you can use an assert -task to check for allowed values. This way, you cannot accidentally delete the production databases. --- - hosts: - localhost vars: db_list_backend: - cms - fms allowed_environments: - dev - qa vars_prompt: - name: db_environment prompt: \"Attention: This will delete all databases in the desired environment! Please enter the environment (dev, qa):\" tasks: - name: Assert that db_environment is allowed environment ansible.builtin.assert: that: db_environment in allowed_environments fail_msg: \"{{ db_environment }} is not a valid environment\" tags: - always - name: Drop all backend databases community.mysql.mysql_db: login_user: mysqlroot login_password: \"password\" login_host: \"mysqlserver\" name: \"{{ item }}\" state: absent loop: \"{{ db_list_backend }}\" The final ansible-playbook call would look like this: ansible-playbook playbook.yaml --extra-vars=\"db_environment=dev\"","title":"Good"},{"location":"name_your_tasks/","text":"Name your tasks and plays When writing tasks and plays in Ansible naming them is optional. However you should always give useful names to your tasks ands plays. Bad When you run a playbook without named tasks, you\u2019ll see the following output. - hosts: all tasks: - ansible.builtin.include_vars: foo.yml - ansible.builtin.yum: name: httpd PLAY [localhost] ******************************** TASK [include_vars] ******************************** ok: [localhost] TASK [yum] ******************************** ok: [localhost] Good When trying to debug failed tasks it\u2019s really helpful to actually know what task failed and what the task should have been doing. Assigning names to your taks will give the following output. - name: install apache hosts: all tasks: - name: include the config vars for the apache ansible.builtin.include_vars: foo.yml - name: install apache with yum ansible.builtin.yum: name: httpd PLAY [install apache] ******************************** TASK [include the config vars for the apache] ******************************** ok: [localhost] TASK [install apache with yum] ******************************** ok: [localhost]","title":"Name your tasks and plays"},{"location":"name_your_tasks/#name-your-tasks-and-plays","text":"When writing tasks and plays in Ansible naming them is optional. However you should always give useful names to your tasks ands plays.","title":"Name your tasks and plays"},{"location":"name_your_tasks/#bad","text":"When you run a playbook without named tasks, you\u2019ll see the following output. - hosts: all tasks: - ansible.builtin.include_vars: foo.yml - ansible.builtin.yum: name: httpd PLAY [localhost] ******************************** TASK [include_vars] ******************************** ok: [localhost] TASK [yum] ******************************** ok: [localhost]","title":"Bad"},{"location":"name_your_tasks/#good","text":"When trying to debug failed tasks it\u2019s really helpful to actually know what task failed and what the task should have been doing. Assigning names to your taks will give the following output. - name: install apache hosts: all tasks: - name: include the config vars for the apache ansible.builtin.include_vars: foo.yml - name: install apache with yum ansible.builtin.yum: name: httpd PLAY [install apache] ******************************** TASK [include the config vars for the apache] ******************************** ok: [localhost] TASK [install apache with yum] ******************************** ok: [localhost]","title":"Good"},{"location":"prefix_your_variables/","text":"Prefix your variables You should prefix your variables with the name of the role (or playbook). This makes it easier to know where the variable is used. Here\u2019s an example. Imagine you\u2019re writing a role to install and configure the Apache web-server (you probably don\u2019t have to). The role is named apache . Now you want to create a variable that configures the default listen-port. Bad - hosts: localhost vars: listen_port: 443 tasks: - name: configure apache ansible.builtin.template: src: httpd.conf.j2 dest: /etc/httpd/conf/httpd.conf Good - hosts: localhost vars: apache_listen_port: 443 tasks: - name: configure apache ansible.builtin.template: src: httpd.conf.j2 dest: /etc/httpd/conf/httpd.conf Other than the reason mentioned earlier, there\u2019s no ambiguity here. You definitely know that this variable belongs to the apache-role. There could be another role for some other kind of software that also defines a listen-port. With prefixed variables this is not a problem since variables have their own namespace now. By the way, Puppet and Chef are on the advantage here, having namespaces for their roles. Ansible is not designed this way.","title":"Prefix your variables"},{"location":"prefix_your_variables/#prefix-your-variables","text":"You should prefix your variables with the name of the role (or playbook). This makes it easier to know where the variable is used. Here\u2019s an example. Imagine you\u2019re writing a role to install and configure the Apache web-server (you probably don\u2019t have to). The role is named apache . Now you want to create a variable that configures the default listen-port.","title":"Prefix your variables"},{"location":"prefix_your_variables/#bad","text":"- hosts: localhost vars: listen_port: 443 tasks: - name: configure apache ansible.builtin.template: src: httpd.conf.j2 dest: /etc/httpd/conf/httpd.conf","title":"Bad"},{"location":"prefix_your_variables/#good","text":"- hosts: localhost vars: apache_listen_port: 443 tasks: - name: configure apache ansible.builtin.template: src: httpd.conf.j2 dest: /etc/httpd/conf/httpd.conf Other than the reason mentioned earlier, there\u2019s no ambiguity here. You definitely know that this variable belongs to the apache-role. There could be another role for some other kind of software that also defines a listen-port. With prefixed variables this is not a problem since variables have their own namespace now. By the way, Puppet and Chef are on the advantage here, having namespaces for their roles. Ansible is not designed this way.","title":"Good"},{"location":"turn_off_gather_facts/","text":"Turn off gather_facts if you don't need it If you execute a playbook with yaml gather_facts: true , Ansible starts collecting facts (data from your node that is stored into variables). These details include variables from the remote host such as network configuration variables, hostnames and so on. The collection of these facts is a time-consuming process and in order to speed up the execution of the playbook you can turn gathering facts off. Bad --- - hosts: all become: true gather_facts: true tasks: - name: restart mysql ansible.builtin.service: name: mysql state: restarted Good --- - hosts: all become: true gather_facts: false tasks: - name: restart mysql ansible.builtin.service: name: mysql state: restarted Keep in mind that you need to enable gather_facts if you want to use host-variables or want to collect information about the remote host. A list about some of these Ansible facts can be found here: https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html#ansible-facts","title":"Turn off gather_facts if you don't need it"},{"location":"turn_off_gather_facts/#turn-off-gather_facts-if-you-dont-need-it","text":"If you execute a playbook with yaml gather_facts: true , Ansible starts collecting facts (data from your node that is stored into variables). These details include variables from the remote host such as network configuration variables, hostnames and so on. The collection of these facts is a time-consuming process and in order to speed up the execution of the playbook you can turn gathering facts off.","title":"Turn off gather_facts if you don't need it"},{"location":"turn_off_gather_facts/#bad","text":"--- - hosts: all become: true gather_facts: true tasks: - name: restart mysql ansible.builtin.service: name: mysql state: restarted","title":"Bad"},{"location":"turn_off_gather_facts/#good","text":"--- - hosts: all become: true gather_facts: false tasks: - name: restart mysql ansible.builtin.service: name: mysql state: restarted Keep in mind that you need to enable gather_facts if you want to use host-variables or want to collect information about the remote host. A list about some of these Ansible facts can be found here: https://docs.ansible.com/ansible/latest/user_guide/playbooks_vars_facts.html#ansible-facts","title":"Good"},{"location":"use_copy_template_instead_of_lineinfile/","text":"Use copy or template-module instead of lineinfile It\u2019s often necessary to change single lines in files. When having to do this, many people will use the lineinfile or blockinfile modules to change the file. However over the years I learned that most times you should in fact not use these modules when wanting to changes files. You should rather use the template- or copy-module to manage not only single lines but the whole file itself. The reason for that is twofold. First when using lineinfile you often have to use regex. Now you have two problems. More seriously, using regex is often okay, if the regex is simple (or you and the people using your playbooks are experienced with regex)! The second reason is that you have to know and remember that this particular line in this config-file is managed by Ansible. If you manage the whole file with template you can use the ansible_managed-variable to show that the file is under Ansible control. Bad - ansible.builtin.lineinfile: path: /etc/selinux/config regexp: '^SELINUX=' line: 'SELINUX=enforcing' Good - ansible.builtin.copy: src: \"etc/selinux/config\" dest: \"/etc/selinux/config\" Also Good - ansible.builtin.template: src: \"etc/selinux/config.j2\" dest: \"/etc/selinux/config\" with the template file looking like this: # {{ansible_managed}} SELINUX=enforcing SELINUXTYPE=targeted Bonus: you can use a variable for the selinux-state and simply change it on servers where selinux should not be in enforcing state.","title":"Use copy or template-module instead of lineinfile"},{"location":"use_copy_template_instead_of_lineinfile/#use-copy-or-template-module-instead-of-lineinfile","text":"It\u2019s often necessary to change single lines in files. When having to do this, many people will use the lineinfile or blockinfile modules to change the file. However over the years I learned that most times you should in fact not use these modules when wanting to changes files. You should rather use the template- or copy-module to manage not only single lines but the whole file itself. The reason for that is twofold. First when using lineinfile you often have to use regex. Now you have two problems. More seriously, using regex is often okay, if the regex is simple (or you and the people using your playbooks are experienced with regex)! The second reason is that you have to know and remember that this particular line in this config-file is managed by Ansible. If you manage the whole file with template you can use the ansible_managed-variable to show that the file is under Ansible control.","title":"Use copy or template-module instead of lineinfile"},{"location":"use_copy_template_instead_of_lineinfile/#bad","text":"- ansible.builtin.lineinfile: path: /etc/selinux/config regexp: '^SELINUX=' line: 'SELINUX=enforcing'","title":"Bad"},{"location":"use_copy_template_instead_of_lineinfile/#good","text":"- ansible.builtin.copy: src: \"etc/selinux/config\" dest: \"/etc/selinux/config\"","title":"Good"},{"location":"use_copy_template_instead_of_lineinfile/#also-good","text":"- ansible.builtin.template: src: \"etc/selinux/config.j2\" dest: \"/etc/selinux/config\" with the template file looking like this: # {{ansible_managed}} SELINUX=enforcing SELINUXTYPE=targeted Bonus: you can use a variable for the selinux-state and simply change it on servers where selinux should not be in enforcing state.","title":"Also Good"},{"location":"use_modules_before_run_commands/","text":"Use Modules Before Run Commands Ansible is batteries-included and comes with more than 6000 modules to help manage systems. Most times it\u2019s not needed (nor useful!) to fall back to shell commands instead of using modules. Bad - name: install htop hosts: all tasks: - name: install htop ansible.builtin.command: \"yum install htop -y\" Good - name: install htop hosts: all tasks: - name: install htop ansible.builtin.yum: name: \"htop\" state: present Ansible is helpful in detecting when you should use modules instead of commands. It detects these uses and prints a warning. When running the above task with command Ansible prints: TASK [command] *********************** [WARNING]: Consider using yum module rather than running yum","title":"Use Modules Before Run Commands"},{"location":"use_modules_before_run_commands/#use-modules-before-run-commands","text":"Ansible is batteries-included and comes with more than 6000 modules to help manage systems. Most times it\u2019s not needed (nor useful!) to fall back to shell commands instead of using modules.","title":"Use Modules Before Run Commands"},{"location":"use_modules_before_run_commands/#bad","text":"- name: install htop hosts: all tasks: - name: install htop ansible.builtin.command: \"yum install htop -y\"","title":"Bad"},{"location":"use_modules_before_run_commands/#good","text":"- name: install htop hosts: all tasks: - name: install htop ansible.builtin.yum: name: \"htop\" state: present Ansible is helpful in detecting when you should use modules instead of commands. It detects these uses and prints a warning. When running the above task with command Ansible prints: TASK [command] *********************** [WARNING]: Consider using yum module rather than running yum","title":"Good"},{"location":"use_native_yaml_syntax/","text":"Use native YAML syntax for your Ansible code There are several ways you can write your code in Ansible. At its core, the Ansible playbook runner is a YAML parser with added logic such as: commandline key=value Bad Using the key=value shorthand format will limit the readability of your code: - name: install telegraf ansible.builtin.yum: name: telegraf-{{ telegraf_version }} state=present update_cache=yes disable_gpg_check=yes enablerepo=telegraf notify: restart telegraf - name: configure telegraf ansible.builtin.template: src=telegraf.conf.j2 dest=/etc/telegraf/telegraf.conf notify: restart telegraf Good Using native YAML has a few more lines but it reduces horizontal scrolling and line wrapping. Another benefit is the improved syntax highlighting in modern text editor software. - name: install telegraf ansible.builtin.yum: name: telegraf-{{ telegraf_version }} state: present update_cache: yes disable_gpg_check: yes enablerepo: telegraf notify: restart telegraf - name: configure telegraf ansible.builtin.template: src: telegraf.conf.j2 dest: /etc/telegraf/telegraf","title":"Use native YAML syntax for your Ansible code"},{"location":"use_native_yaml_syntax/#use-native-yaml-syntax-for-your-ansible-code","text":"There are several ways you can write your code in Ansible. At its core, the Ansible playbook runner is a YAML parser with added logic such as: commandline key=value","title":"Use native YAML syntax for your Ansible code"},{"location":"use_native_yaml_syntax/#bad","text":"Using the key=value shorthand format will limit the readability of your code: - name: install telegraf ansible.builtin.yum: name: telegraf-{{ telegraf_version }} state=present update_cache=yes disable_gpg_check=yes enablerepo=telegraf notify: restart telegraf - name: configure telegraf ansible.builtin.template: src=telegraf.conf.j2 dest=/etc/telegraf/telegraf.conf notify: restart telegraf","title":"Bad"},{"location":"use_native_yaml_syntax/#good","text":"Using native YAML has a few more lines but it reduces horizontal scrolling and line wrapping. Another benefit is the improved syntax highlighting in modern text editor software. - name: install telegraf ansible.builtin.yum: name: telegraf-{{ telegraf_version }} state: present update_cache: yes disable_gpg_check: yes enablerepo: telegraf notify: restart telegraf - name: configure telegraf ansible.builtin.template: src: telegraf.conf.j2 dest: /etc/telegraf/telegraf","title":"Good"}]}